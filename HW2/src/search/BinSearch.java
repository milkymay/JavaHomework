package search;

public class BinSearch {
    // pre: массив a[] отсортирован по неубыванию, х - искомое
    // I: l < r && a[l] > x >= a[r] (a[-1] = +inf, a[n] = -inf) && a отсортирован по неубыванию
    public static int iterative(int[] a, int x) {
        int l = -1, r = a.length;
        // l = -1; (левая граница) r = n; (правая граница) && I
        while(r - l > 1) {
            // Iw: I && r - l > 1, то есть длина рассматриваемого интервала превосходит один (не сошлись в элементе)
            int m = (l + r) / 2;
            // m - середина массива, m = (l + r) / 2, округлённое вниз; значение a[m] можно анализировать для выбора половины
            if (a[m] > x) {
                // a[m] > x
                l = m;
                // a[m] > x && l' = m && r' = r && I,
                // т.к. массив a[] отсортирован, и если a[m] > x, то для любого i из (l, m] a[i] > x,
                // значит такие i можно исключить из рассмотрения
            } else {
                //a[m] <= x
                r = m;
                //a[m] <= x && r' = m && l' = l && I,
                // т.к. массив a[] отсортирован, и если a[m] <= x, то для любого i из (m, r] существует меньший индекс m,
                // удовлетворяющий условиям, значит такие i можно исключить из рассмотрения
            }
            // I && (r' - l' == (r - l) / 2), т.к один из индексов сместился на середину, тогда как другой остался неизменным
        }
        // r - l <= 1, но т.к. некоторое положительное число (r - l >= 1) на каждом шаге уменьшали в два раза
        // только при условии r - l > 1, в итоге получим r - l == 1 - т.е. мы сошлись в одном элементе, который,
        // согласно сохранению инварианта, доказанному выше, и является искомым индексом R
        return  r;
    }
    // post: {массив в исходном состоянии, x' = x
    // R (r) - индекс x, если он есть в массиве; минимально возможный индекс i такой, что a[i] <= x && 0 <= i < n;
    // a.length, если все элементы меньше х}


    // pre: субмассив a[l..r] отсортирован по неубыванию
    // I: l < r && a[l] >= x > a[r] (a[n] = -inf, a[-1] = +inf)
    public static int recursive_upper(int[] a, int x, int l, int r) {
        if (r - l <= 1) {
            // т.к. некоторое положительное число (r - l >= 1) на каждом шаге уменьшали в два раза
            // только при условии r - l > 1, в итоге получим r - l == 1 - т.е. мы сошлись в одном элементе, который,
            // согласно сохранению инварианта, доказанному ниже, и является искомым индексом R:
            // a[r] - первый меньший, т.к. x > a[r] (строгое неравенство)
            return r;
        }
        // r > l + 1, длина промежутка > 1
        int m = (l + r) / 2;
        // m - середина отрезка
        if (a[m] >= x) {
            // т.к. левая граница включается, неравенство a[m] >= x нестрогое
            // (равенство, не требующее включения границы будет рассмотрено в ветке else)
            // т.к. массив a[] отсортирован, и если a[m] >= x, то для любого i из [l, m) a[i] >= x,
            // а мы ищем минимально возможный индекс R такой, что a[R] < x
            // значит такие i можно исключить из рассмотрения (не подходят под условие поиска)
            // т.о. I сохраняется
            return recursive_upper(a, x, m, r);
        } else {
            // правая граница не включается (m станет правой границей), поэтому неравенство a[m] < x строгое
            // т.к. массив a[] отсортирован, и если a[m] < x, то для любого i из [m, r) существует меньший индекс m,
            // удовлетворяющий условиям, значит такие i можно исключить из рассмотрения - запустим тот же алгоритм,
            // отбросив значения, не влияющие на ответ
            // т.о. I сохраняется
            return recursive_upper(a, x, l, m);
        }
        // углубились в ту половину массива, в которой находится х (доказано выще)
        // a[l'] >= x > a[r'] (a[n] = -inf, a[-1] = +inf) && (r' - l') = (r - l) / 2
    }
    // post: {субмассив a[l..r] в исходном состоянии, x' = x;
    // если (a[m] >= x) то {l' = m && r' = r} иначе {l' = l && r' = m}
    // a[l'] >= x > a[r'] (a[n] = -inf, a[-1] = +inf)}
    // R - индекс первого элемента, меньшего ключа, или a.length,
    // если все элементы в массиве меньше х.


    // pre: субмассив a[l..r] отсортирован по неубыванию
    // I: l < r && a[l] > x >= a[r] (a[n] = -inf, a[-1] = +inf)
    public static int recursive(int[] a, int x, int l, int r) {
        if (r - l <= 1) {
            // т.к. некоторое положительное число (r - l >= 1) на каждом шаге уменьшали в два раза
            // только при условии r - l > 1, в итоге получим r - l == 1 - т.е. мы сошлись в одном элементе, который,
            // согласно сохранению инварианта, доказанному ниже, и является искомым индексом R:
            // a[r] - равный или первый меньший, т.к. x >= a[r] (нестрогое неравенство)
            return r;
        }
        // r > l + 1, длина промежутка > 1
        int m = (l + r) / 2;
        // m - середина отрезка
        if (a[m] > x) {
            // т.к. левая граница не включается, неравенство a[m] > x строгое
            // (равенство, требующее включения границы будет рассмотрено в ветке else)
            // т.к. массив a[] отсортирован, и если a[m] > x, то для любого i из (l, m] a[i] > x,
            // а мы ищем минимально возможный индекс R такой, что a[R] <= x
            // значит такие i можно исключить из рассмотрения (не подходят под условие поиска)
            // т.о. I сохраняется
            return recursive(a, x, m, r);
        } else {
            // правая граница включается (m станет правой границей), поэтому неравенство a[m] <= x нестрогое
            // т.к. массив a[] отсортирован, и если a[m] <= x, то для любого i из (m, r] существует меньший индекс m,
            // удовлетворяющий условиям, значит такие i можно исключить из рассмотрения - запустим тот же алгоритм,
            // отбросив значения, не влияющие на ответ
            // т.о. I сохраняется
            return recursive(a, x, l, m);
        }
        // углубились в ту половину массива, в которой находится х (доказано выще)
        // a[l'] > x >= a[r'] (a[n] = -inf, a[-1] = +inf) && (r' - l') = (r - l) / 2
    }
    // post: {субмассив a[l..r] в исходном состоянии, x' = x;
    // если (a[m] > x) то {l' = m && r' = r} иначе {l' = l && r' = m}
    // a[l'] > x >= a[r'] (a[n] = -inf, a[-1] = +inf)}
    // R - индекс x, если он содержится в массиве; иначе
    // индекс первого элемента, меньшего ключа, или a.length,
    // если все элементы в массиве меньше х.
}
