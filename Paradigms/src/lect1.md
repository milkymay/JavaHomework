##### Lecture 1
### Программирование по контракту

# Теорема Райса ~ 
"Нельзя просто так взять и понять код"

# Ограничения для примера про возведение в степень:

- N неотрицательное
- a != 0 || n != 0
- R = a^n, где R - выходное значение

Предусловия - ограничения, на которых должна работать функция.
Постусловие - ограничение на возвращаемое значение

# Тройки Хоара (Утверждение про фрагмент кода)
(Хоар - логик, автор QuickSort'а)
P Предусловие
C Код
S Постусловие

Механизм, который позваоляет доказывать, что наш код делает обещанное

# Теорема о структурировании (Бёма-Якопини)
"Любой граф потока управления можно преобразовать так, чтобы он использовал только: 
последовательное исполнение, условие, цикл while (+присваивание)"

# IF
P1, C1, S1;
P2, C2, S2;

Если S1 => P2, то
P1, C1, C2 => S2;

Если (условие), то C1 else C2

P & (condition) => P1 
P & (condition) => P2
S1 => S, S2 => S 

# CYCLE
P' C' S'
while (condition) {
    P C S
}
P' & cond => P
P' & !cond => S'
S & !cond => S' (break)
S & cond => P (continue)

Инвариант (I) цикла
На входе требуем, чтобы 
I ^ cond => P
I ^ cond => I
S => I
```
Для цикла нужны: инвариант и условие (гарантия) завершения. Так, окончание цикла гарантирует выполнение постусловий
```
Извлечение корня
Пред: x >= 0
Пост: R * R = x, R >= 0
A = sqtr(x)
Чтобы вызвать фукнцию 
P' a = F(b) S'
P' => P(x -> b)
S(R -> a) => S'

``` 
Чистая функция - функция, результат который зависит только от входных данных, не имеющая побочных эффектов.
```
Если нечистую фукнцию с её инвариантом поместить в цикл I цикла содержит I функции 
(однако скрытые переменные фукнции, в отлисие от переменных цикла, менять нельхя)

#Summary
Тройки Хоара и их использование для анализа и доказательства работы кода
Контракты (не)чистых функций
